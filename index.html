<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AURA v4.0 | Advanced Hybrid Optical Engine</title>
    
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

    <style>
        :root {
            --primary: #00f3ff;
            --secondary: #bc13fe;
            --bg: #050505;
            --panel: #0f1115;
            --text: #e0e0e0;
            --border: #333;
            --accent: #ff6b35;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
        }

        .container {
            width: 90%;
            max-width: 900px;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 2.5rem;
            box-shadow: 0 0 60px rgba(0, 243, 255, 0.08);
            text-align: center;
            position: relative;
        }

        .glow {
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--primary), var(--secondary), var(--accent));
            border-radius: 22px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .container:hover .glow { opacity: 0.1; }

        h1 {
            margin: 0 0 0.5rem;
            font-weight: 300;
            letter-spacing: 5px;
            background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2.2rem;
        }

        .subtitle {
            color: #888;
            font-size: 0.95rem;
            margin-bottom: 2rem;
            letter-spacing: 1px;
        }

        .badge {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: #000;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 243, 255, 0.3);
            vertical-align: middle;
        }

        /* Drop Zone */
        .drop-zone {
            margin-top: 20px;
            border: 2px dashed var(--border);
            border-radius: 16px;
            padding: 70px 30px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: rgba(255, 255, 255, 0.02);
            position: relative;
            overflow: hidden;
        }

        .drop-zone::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 243, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .drop-zone:hover::before { left: 100%; }

        .drop-zone:hover {
            border-color: var(--primary);
            background: rgba(0, 243, 255, 0.08);
            box-shadow: inset 0 0 30px rgba(0, 243, 255, 0.15), 0 0 20px rgba(0, 243, 255, 0.1);
        }

        .drop-zone.dragover {
            border-color: var(--secondary);
            background: rgba(188, 19, 254, 0.08);
            transform: scale(1.02);
        }

        .drop-zone p { 
            color: #888; 
            font-size: 1.2rem; 
            margin: 0;
            line-height: 1.6;
        }
        
        .drop-icon { font-size: 3rem; margin-bottom: 1rem; opacity: 0.7; }
        
        /* Preview */
        #preview {
            max-width: 100%;
            max-height: 400px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 243, 255, 0.2);
            margin-top: 20px;
            display: none;
        }
        
        /* Console Log */
        .console {
            margin-top: 25px;
            background: #000;
            border: 1px solid #222;
            border-radius: 12px;
            height: 220px;
            overflow-y: auto;
            text-align: left;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #aaa;
            position: relative;
        }

        .console::-webkit-scrollbar {
            width: 6px;
        }

        .console::-webkit-scrollbar-track {
            background: #111;
        }

        .console::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 3px;
        }
        
        .log-entry { 
            margin-bottom: 8px; 
            border-left: 4px solid transparent; 
            padding-left: 12px; 
            animation: fadeIn 0.3s ease;
            word-break: break-all;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .log-info { border-color: #555; }
        .log-success { border-color: var(--primary); color: var(--primary); }
        .log-error { border-color: #ff3355; color: #ff3355; }
        .log-cloud { border-color: var(--secondary); color: var(--secondary); }
        .log-warning { border-color: var(--accent); color: var(--accent); }

        /* Buttons & Loader */
        .btn-group { 
            margin-top: 25px; 
            display: flex; 
            justify-content: center; 
            gap: 20px; 
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 14px 35px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            text-decoration: none;
            display: none;
            transition: all 0.3s ease;
            font-size: 0.95rem;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before { left: 100%; }

        .btn-download { 
            background: linear-gradient(135deg, var(--primary), var(--secondary)); 
            color: #000; 
            box-shadow: 0 0 20px rgba(0,243,255,0.4); 
        }
        
        .btn-download:hover { 
            transform: translateY(-2px);
            box-shadow: 0 5px 25px rgba(0,243,255,0.6);
        }
        
        .btn-reset { 
            background: #222; 
            color: #fff; 
            border: 1px solid #444; 
            display: inline-block; 
        }
        .btn-reset:hover { 
            background: #333; 
            border-color: var(--primary);
            transform: translateY(-1px);
        }

        .loader {
            width: 100%; 
            height: 5px; 
            background: #222; 
            margin-top: 20px;
            border-radius: 3px; 
            overflow: hidden; 
            display: none;
        }
        .loader-bar { 
            height: 100%; 
            background: linear-gradient(90deg, var(--secondary), var(--primary), var(--accent)); 
            width: 0%; 
            transition: width 0.4s ease;
            position: relative;
        }

        .loader-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 20px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-20px); }
            100% { transform: translateX(100%); }
        }

        canvas { display: none; }
        
        .warning {
            background: rgba(255, 107, 53, 0.1);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            color: var(--accent);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>

<div class="container">
    <div class="glow"></div>
    <h1>AURA <span class="badge">v4.0 UPGRADED</span></h1>
    <p class="subtitle">Advanced Hybrid Optical Data Matrix | Firestore Synced | Robust Fallbacks</p>

    <div class="drop-zone" id="dropZone">
        <div class="drop-icon">üìÅ</div>
        <p>Drag & Drop File to Encode<br><span style="font-size:0.9rem; opacity:0.8;">üñºÔ∏è Drop Image to Decode (Fallback to Encode if Invalid)</span></p>
        <input type="file" id="fileInput" hidden accept="*/*">
    </div>

    <div class="loader" id="loader"><div class="loader-bar" id="loaderBar"></div></div>
    <div id="warning" class="warning" style="display:none;"></div>

    <img id="preview" alt="Encoded/Decoded Preview">

    <div class="console" id="consoleLog">
        <div class="log-entry log-info">> AURA v4.0 Initialized - Ready for Optical Processing...</div>
    </div>

    <div class="btn-group">
        <a id="downloadBtn" class="btn btn-download">‚¨á DOWNLOAD OPTICAL CODE</a>
        <button class="btn btn-reset" onclick="location.reload()">‚Üª RESET SESSION</button>
    </div>

    <canvas id="processor"></canvas>
</div>

<script>
    /**
     * AURA v4.0 - Fully Polished & Upgraded
     * Upgrades: Robust Header Detection, Image Fallback, Alpha Fix, UI Enhancements, File Size Limits, Latest Firebase
     * Features: Auto-Preview, Shimmer Effects, Better Error Handling, Max Canvas Size Check
     */

    // --- 1. FIREBASE CONFIGURATION (Updated to v10.12.2) ---
    const firebaseConfig = {
        apiKey: "AIzaSyD60VG7aqXr-3TFKBdQRT8XbaEl54J3f8s",
        authDomain: "experiment-26a5c.firebaseapp.com",
        projectId: "experiment-26a5c",
        storageBucket: "experiment-26a5c.firebasestorage.app",
        messagingSenderId: "791493232373",
        appId: "1:791493232373:web:f1fb821e86752ea7a4a7bc"
    };

    // Init Firebase with Enhanced Error Handling
    let db;
    try {
        firebase.initializeApp(firebaseConfig);
        db = firebase.firestore();
        log("‚úì Firebase Cloud Sync Established.", "cloud");
    } catch (e) {
        log("‚úó Firebase Initialization Failed: " + e.message + " (Offline Mode Enabled)", "error");
        db = null; // Fallback to local-only
    }

    // --- 2. DOM ELEMENTS ---
    const ui = {
        dropZone: document.getElementById('dropZone'),
        fileInput: document.getElementById('fileInput'),
        console: document.getElementById('consoleLog'),
        canvas: document.getElementById('processor'),
        ctx: document.getElementById('processor').getContext('2d', { willReadFrequently: true, alpha: true }), // Fixed: Alpha enabled
        dlBtn: document.getElementById('downloadBtn'),
        loader: document.getElementById('loader'),
        loaderBar: document.getElementById('loaderBar'),
        preview: document.getElementById('preview'),
        warning: document.getElementById('warning')
    };

    // --- 3. EVENT HANDLERS (Polished Drag States) ---
    ui.dropZone.onclick = () => ui.fileInput.click();
    ui.fileInput.onchange = (e) => processFile(e.target.files[0]);

    ui.dropZone.ondragover = (e) => {
        e.preventDefault();
        ui.dropZone.classList.add('dragover');
    };
    ui.dropZone.ondragleave = () => ui.dropZone.classList.remove('dragover');
    ui.dropZone.ondrop = (e) => {
        e.preventDefault();
        ui.dropZone.classList.remove('dragover');
        processFile(e.dataTransfer.files[0]);
    };

    // --- 4. MAIN PROCESSOR (Upgraded with Fallback Logic) ---
    async function processFile(file) {
        if (!file) return;
        clearUI();
        
        const maxSize = 5 * 1024 * 1024; // 5MB limit
        if (file.size > maxSize) {
            log("‚ö† File too large (>5MB). Optical encoding limited for performance.", "warning");
            showWarning("File exceeds 5MB limit. Please use smaller files.");
            return;
        }

        log(`Processing: \( {file.name} ( \){(file.size / 1024).toFixed(1)} KB)`, "info");

        if (file.type.startsWith("image/")) {
            log("Image detected. Attempting AURA decode...", "info");
            await decode(file);
        } else {
            log("File detected. Encoding to optical matrix...", "info");
            await encode(file);
        }
    }

    // --- 5. ENCODE LOGIC (Enhanced: Preview, Size Check) ---
    async function encode(file) {
        try {
            loading(10);
            const fileId = "AURA-" + Date.now().toString(36) + Math.random().toString(36).substr(2, 8); // Longer random for uniqueness
            log(`Generated Secure ID: ${fileId}`, "success");

            // 1. Read File
            const buffer = await file.arrayBuffer();
            const rawData = new Uint8Array(buffer);
            loading(30);

            // 2. Sync Metadata (Cloud with Fallback)
            log("Syncing metadata...", "cloud");
            if (db) {
                await db.collection("aura_registry").doc(fileId).set({
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    date: new Date().toISOString()
                }).catch(e => log("Metadata sync failed (local mode): " + e.message, "warning"));
            }

            // 3. Prepare Payload
            const separator = ":::AURA_SEP:::"; // Upgraded unique separator
            const header = new TextEncoder().encode(fileId + separator);
            
            // 4. PADDING: Ensure divisible by 3
            const totalLen = header.length + rawData.length;
            const padding = (3 - (totalLen % 3)) % 3;
            const finalLen = totalLen + padding;

            const finalBuffer = new Uint8Array(finalLen);
            finalBuffer.set(header, 0);
            finalBuffer.set(rawData, header.length);
            // Padding 0s at end

            loading(50);
            log("Rendering advanced optical grid...", "info");

            // 5. Grid Size with Limit Check
            const totalPixels = finalLen / 3;
            let side = Math.ceil(Math.sqrt(totalPixels));
            const maxSide = 2048; // Canvas limit
            if (side > maxSide) {
                log("‚ö† Grid too large. Resizing with warning.", "warning");
                side = maxSide;
                showWarning(`Image resized to \( {maxSide}x \){maxSide} (data preserved, extra padding added).`);
            }
            
            ui.canvas.width = side;
            ui.canvas.height = side;
            
            const imgData = ui.ctx.createImageData(side, side);
            const actualPixels = Math.min(totalPixels, side * side);
            
            // 6. Optimized Pixel Mapping
            for (let i = 0; i < actualPixels; i++) {
                const bufIdx = i * 3;
                const pixIdx = i * 4;
                
                imgData.data[pixIdx] = finalBuffer[bufIdx];     // R
                imgData.data[pixIdx + 1] = finalBuffer[bufIdx + 1 || 0]; // G (safe)
                imgData.data[pixIdx + 2] = finalBuffer[bufIdx + 2 || 0]; // B (safe)
                imgData.data[pixIdx + 3] = 255; // Opaque
            }

            ui.ctx.putImageData(imgData, 0, 0);
            loading(90);

            // 7. Preview & Download
            ui.preview.src = ui.canvas.toDataURL("image/png");
            ui.preview.style.display = "block";
            ui.dlBtn.href = ui.preview.src;
            ui.dlBtn.download = `AURA_CODE_${file.name}.png`;
            ui.dlBtn.style.display = "inline-block";
            
            loading(100);
            log("‚úÖ Encoding Complete! Optical code ready with preview.", "success");

        } catch (err) {
            log("‚úó Encoding Error: " + err.message, "error");
            showWarning("Encoding failed. Check console and try again.");
        }
    }

    // --- 6. DECODE LOGIC (Upgraded: Robust Detection, Fallback) ---
    async function decode(file) {
        try {
            loading(20);
            const img = new Image();
            const objectURL = URL.createObjectURL(file);
            img.src = objectURL;
            
            img.onload = async () => {
                URL.revokeObjectURL(objectURL); // Clean up
                ui.canvas.width = img.width;
                ui.canvas.height = img.height;
                ui.ctx.drawImage(img, 0, 0);
                
                const imgData = ui.ctx.getImageData(0, 0, img.width, img.height);
                const pixels = imgData.data;
                
                // Extract RGB (Ignore Alpha)
                const totalBytes = (pixels.length / 4) * 3;
                const buffer = new Uint8Array(totalBytes);
                
                for (let i = 0, j = 0; i < pixels.length; i += 4, j += 3) {
                    buffer[j] = pixels[i];
                    buffer[j + 1] = pixels[i + 1];
                    buffer[j + 2] = pixels[i + 2];
                }

                loading(50);
                log("Scanning for AURA signature...", "info");

                // Enhanced Header Detection: Search for unique separator
                const decoder = new TextDecoder();
                let fileId = null;
                const sepBytes = new TextEncoder().encode(":::AURA_SEP:::");
                const sepLen = sepBytes.length;
                
                // Binary search for separator (more robust)
                for (let start = 0; start < buffer.length - sepLen - 10; start++) { // Min ID length
                    let match = true;
                    for (let k = 0; k < sepLen; k++) {
                        if (buffer[start + k] !== sepBytes[k]) {
                            match = false;
                            break;
                        }
                    }
                    if (match) {
                        const potentialIdBytes = buffer.subarray(0, start);
                        const potentialId = decoder.decode(potentialIdBytes);
                        if (potentialId.startsWith("AURA-")) {
                            fileId = potentialId;
                            break;
                        }
                    }
                }

                if (!fileId) {
                    log("No valid AURA signature detected. Falling back to encode mode.", "warning");
                    ui.preview.src = URL.createObjectURL(file);
                    ui.preview.style.display = "block";
                    loading(100);
                    return await encode(file); // Fallback
                }

                const headerStr = fileId + ":::AURA_SEP:::";
                const headerLen = new TextEncoder().encode(headerStr).length;

                log(`‚úì AURA Signature Verified: ${fileId}`, "success");
                loading(60);
                
                // Fetch Metadata
                let meta = null;
                if (db) {
                    log("Fetching secure metadata from Cloud...", "cloud");
                    const doc = await db.collection("aura_registry").doc(fileId).get();
                    if (doc.exists) {
                        meta = doc.data();
                        log(`Recovering: \( {meta.name} ( \){(meta.size / 1024).toFixed(1)} KB)`, "info");
                    } else {
                        log("Metadata expired or missing. Using local extraction.", "warning");
                    }
                }

                // Fallback: If no meta, estimate size (but warn)
                if (!meta) {
                    meta = {
                        name: "recovered_file",
                        size: buffer.length - headerLen, // Approximate
                        type: "application/octet-stream"
                    };
                    log("‚ö† Using approximate recovery (no cloud sync).", "warning");
                    showWarning("Metadata unavailable. File may have trailing artifacts.");
                }

                // Extract Data (Precise Trim)
                const fileData = buffer.subarray(headerLen, Math.min(headerLen + meta.size, buffer.length));
                
                loading(100);
                // Show preview of source image
                ui.preview.src = URL.createObjectURL(file);
                ui.preview.style.display = "block";
                downloadRecovered(fileData, meta.name, meta.type);
            };

            img.onerror = () => {
                URL.revokeObjectURL(objectURL);
                log("Invalid image format. Treating as file to encode.", "warning");
                encode(file);
            };

        } catch (err) {
            log("‚úó Decode Error: " + err.message, "error");
            showWarning("Decode failed. Attempting encode fallback.");
            encode(file);
        }
    }

    // --- 7. UTILITIES (Polished) ---
    function downloadRecovered(data, name, type) {
        const blob = new Blob([data], { type: type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `RECOVERED_${name}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); // Clean up
        log("‚úÖ File Recovered & Downloaded Successfully!", "success");
    }

    function log(msg, type = "info") {
        const div = document.createElement('div');
        div.className = `log-entry log-${type}`;
        div.innerText = `[${new Date().toLocaleTimeString()}] > ${msg}`;
        ui.console.appendChild(div);
        ui.console.scrollTop = ui.console.scrollHeight;
    }

    function loading(pct) {
        ui.loader.style.display = 'block';
        ui.loaderBar.style.width = pct + "%";
        if (pct >= 100) {
            setTimeout(() => {
                ui.loader.style.display = 'none';
                ui.loaderBar.style.width = '0%';
            }, 2000);
        }
    }

    function clearUI() {
        ui.dlBtn.style.display = 'none';
        ui.preview.style.display = 'none';
        ui.preview.src = '';
        ui.warning.style.display = 'none';
        // Optional: Clear console? Uncomment if desired
        // ui.console.innerHTML = '<div class="log-entry log-info">> New Session Started...</div>';
    }

    function showWarning(msg) {
        ui.warning.textContent = msg;
        ui.warning.style.display = 'block';
        setTimeout(() => ui.warning.style.display = 'none', 5000);
    }

</script>
</body>
</html>
